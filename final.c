#pragma config(Sensor, S1,		 frontSensor,		 sensorSONAR)
#pragma config(Sensor, S2,		 leftSensor,		 sensorSONAR)
#pragma config(Motor,	 motorA,					shooter,			 tmotorNXT, PIDControl, encoder)
#pragma config(Motor,	 motorB,					leftMotor,		 tmotorNXT, PIDControl, encoder)
#pragma config(Motor,	 motorC,					rightMotor,		 tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

/*
EDGE CASES
- Assume no dead ends.
- Assume there is enough room for the robot to move/turn successfully.
- Assume robot successfully detects all obstacles in the room.
- Assume optimal starting position.
*/

void moveForwards()
{
	motor[leftMotor] = 20;
	motor[rightMotor] = 20;
}

void stopMove()
{
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void turnLeft()
{
	motor[leftMotor] = -20;
	motor[rightMotor] = 20;
	wait1Msec(1000);
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void turnRight()
{
	motor[leftMotor] = 20;
	motor[rightMotor] = -20;
	wait1Msec(1000);
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

int attackMode(int objDist)
{
	int r = 0;
	clearTimer(T1);
	while(time1[T1]<5000) {
		if(SensorValue[frontSensor] > objDist+2 || SensorValue[frontSensor] < objDist-2) {
			motor[shooter] = 30;
			wait1Msec(3000);
			motor[shooter] = 0;
			r = 1;
		}
		else {
			stopMove();
		}
	}
	return r;
}

task main()
{
	//1. Measuring the size of room before navigation
	wait1Msec(3000);

	while(true)		/* While the Sonar Sensor readings are greater */
	{
		if(SensorValue[frontSensor] > 25)
		{
			moveForwards();
		}
		else
		{
			/*Robot waits for object to move.
			If object moves, the robot will attack.
			If not, the robot attempts to make a turn.*/
			stopMove();
			int objDist = SensorValue[frontSensor];
			int r = attackMode(objDist);
			if (r == 1) {
				continue;
			}
			else if (SensorValue[leftSensor] > 25) {
				turnLeft();
				continue;
			}
			else
			{
				turnRight();
				continue;
			}
		}
	}
}
