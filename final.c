#pragma config(Sensor, S1,		 frontSensor,		 sensorSONAR)
#pragma config(Sensor, S2,		 leftSensor,		 sensorSONAR)
#pragma config(Sensor, S3,		 soundSensor,		 sensorSoundDB)
#pragma config(Motor,	 motorA,					shooter,			 tmotorNXT, PIDControl, encoder)
#pragma config(Motor,	 motorB,					leftMotor,		 tmotorNXT, PIDControl, encoder)
#pragma config(Motor,	 motorC,					rightMotor,		 tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

void moveForwards()
{
	motor[leftMotor] = 40;
	motor[rightMotor] = 40;
}

void moveBackwards()
{
	motor[leftMotor] = -40;
	motor[rightMotor] = -40;
}

void stopMove()
{
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void turnLeft()
{
	motor[leftMotor] = -20;
	motor[rightMotor] = 20;
	wait1Msec(880);
	stopMove();
	wait1Msec(500);
}

void turnRight()
{
	motor[leftMotor] = 20;
	motor[rightMotor] = -20;
	wait1Msec(880);
	stopMove();
	wait1Msec(500);
}

void nudgeRight()
{
	motor[leftMotor] = 50;
	motor[rightMotor] = 20;
	wait1Msec(100);
	motor[leftMotor] = 20;
	motor[rightMotor] = 30;
	wait1Msec(100);
}

int attackMode(int objDist)
{
	int r = 0;
	clearTimer(T1);
	while(time1[T1]<1500) {
		if(SensorValue[frontSensor] > objDist+5 || SensorValue[frontSensor] < objDist-5) {
			playSound(soundBeepBeep);

			motor[shooter] = 45;
			wait1Msec(500);
			motor[shooter] = 0;
			r = 1;
		}
		else {
			stopMove();
		}
	}
	return r;
}

void turnToNoise()
{
	wait1Msec(500);
	short straightSound = SensorValue[soundSensor];
	motor[leftMotor] = -20;
	motor[rightMotor] = 20;
	wait1Msec(200);
	stopMove();
	wait1Msec(500);
	short leftSound = SensorValue[soundSensor];
	motor[leftMotor] = 20;
	motor[rightMotor] = -20;
	wait1Msec(400);
	stopMove();
	wait1Msec(500);
	short rightSound = SensorValue[soundSensor];
	motor[leftMotor] = -20;
	motor[rightMotor] = 20;
	wait1Msec(200);
	if(straightSound > leftSound) {
		if (straightSound < rightSound) {
			short prevSound = SensorValue[soundSensor];
			while (SensorValue[soundSensor] >= prevSound) {
				prevSound = SensorValue[soundSensor];
				motor[leftMotor] = 20;
				motor[rightMotor] = -20;
				wait1Msec(200);
			}
			motor[leftMotor] = -20;
			motor[rightMotor] = 20;
			wait1Msec(200);
		}
	}
	else {
		if (leftSound > rightSound) {
			short prevSound = SensorValue[soundSensor];
			while (SensorValue[soundSensor] >= prevSound) {
				prevSound = SensorValue[soundSensor];
				motor[leftMotor] = -20;
				motor[rightMotor] = 20;
				wait1Msec(200);
			}
			motor[leftMotor] = 20;
			motor[rightMotor] = -20;
			wait1Msec(200);
		}
		else {
			short prevSound = SensorValue[soundSensor];
			while (SensorValue[soundSensor] >= prevSound) {
				prevSound = SensorValue[soundSensor];
				motor[leftMotor] = 20;
				motor[rightMotor] = -20;
				wait1Msec(200);
			}
			motor[leftMotor] = -20;
			motor[rightMotor] = 20;
			wait1Msec(200);
		}
	}
}

task main()
{
	while(true)
	{
		if(SensorValue[frontSensor] > 24 && SensorValue[soundSensor] < 90)
		{
			moveForwards();
			if (SensorValue[leftSensor] < 15) {
				nudgeRight();
				continue;
			}
		}
		else
		{
			stopMove();
			if (SensorValue[soundSensor] >= 90 && SensorValue[frontSensor] > 24) {
				turnToNoise();
				continue;
			}
			wait1Msec(300);
			int objDist = SensorValue[frontSensor];
			if (attackMode(objDist) == 1) {
				continue;
			}
			else {
				if (SensorValue[frontSensor] < 20) {
					moveBackwards();
					wait1Msec(500);
					continue;
				}
				turnRight();
				stopMove();
				short rightVal = SensorValue[frontSensor];
				turnLeft();
				stopMove();
				if (SensorValue[leftSensor] > rightVal){
					turnLeft();
					continue;
				}
				else
				{
					turnRight();
					continue;
				}
			}
		}
	}
}
